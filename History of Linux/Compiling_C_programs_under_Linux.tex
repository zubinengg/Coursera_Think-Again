\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, mathtools}
\usepackage{tikz}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{float}
\usepackage{parskip}
\usepackage{tabularx}
\usepackage[utf8]{inputenc}
\usepackage{tgpagella}
\usepackage[T1]{fontenc}
\usepackage{array}
\usepackage{booktabs}
\usepackage{tcolorbox}
\usepackage{enumitem}

\newcommand{\separator}{\noindent\rule{\linewidth}{1pt}}

\title{History of Linux and the command line}
\author{Zubin}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\newpage

\separator
%-----------------------------------------------------------------

\section{Compiler vs interpreter}

In the C programming language, we use a compiler. To understand the difference between an interpreter and a compiler, we can use an analogy of landing on a planet where inhabitants speak a strange language called "Gobbledygook". To get a mechanic to repair your spaceship, you need a translator.

\subsection{The Interpreter}
If you choose an interpreter:
\begin{itemize}
    \item \textbf{Process:} The interpreter reads your first instruction, translates it immediately, and the mechanic executes it. Then it reads the second, translates, and executes, and so on.
    \item \textbf{Characteristics:} The interpreter stays with you, translating line by line.
    \item \textbf{Pros:} It allows you to correct mistakes as you go (interactive).
    \item \textbf{Cons:} It is a slow process because the mechanic waits for translation between steps.
    \item \textbf{Etymology:} "Inter" means between. The interpreter is always between your program and the computer.
\end{itemize}

\subsection{The Compiler}
If you choose a compiler:
\begin{itemize}
    \item \textbf{Process:} The compiler takes your complete list of instructions and translates the whole lot at once. It then hands the translated list back to you and leaves.
    \item \textbf{Characteristics:} You hand the complete list to the mechanic, who executes them all in one go very quickly.
    \item \textbf{Pros:} Execution is very fast and efficient.
    \item \textbf{Cons:} Takes extra preparation time initially. If there is a mistake, it is too late to fix it during execution.
    \item \textbf{Etymology:} "Compile" means to pile together. It piles together your entire program and translates it all at once.
\end{itemize}

\subsection{Summary}
\begin{itemize}
    \item \textbf{Interpreter:} Runs slowly, starts right away, allows you to see how things are going.
    \item \textbf{Compiler:} Takes preparation time, but runs very quickly and efficiently.
\end{itemize}

\separator

\section{Memory representation:\\ RAM, cells, word, byte, bit, memory address}

How does the computer remember where it has stored the value for a certain variable? To answer this, we need to understand computer memory.

\subsection{Types of Memory}
One role of the operating system is to manage the computer's memory.
\begin{itemize}
    \item \textbf{RAM (Random Access Memory):} Temporary, volatile memory used to execute programs. It is quick to access.
    \item \textbf{Non-volatile Memory:} Permanent storage, such as the hard drive, used for storing files.
\end{itemize}

\subsection{Structure of RAM}
Most programs use RAM during execution.
\begin{itemize}
    \item \textbf{Bit:} A single binary memory cell (0 or 1).
    \item \textbf{Word:} A group of bits forming the fundamental unit of data moved between RAM and the processor.
    \item \textbf{Word Size:} The number of bits in a word (e.g., 8, 16, 32, 64 bits).
    \item \textbf{Byte:} A unit consisting of 8 bits.
\end{itemize}

\subsection{Memory Addressing}
To locate data, memory cells are grouped into words, and each word is assigned an address.
\begin{itemize}
    \item \textbf{Memory Address:} A whole number describing the location of a word in memory (similar to house addresses on a street).
    \item \textbf{Example:} If a computer has 8-bit words:
          \begin{itemize}
              \item Address 0 points to the first word (first 8 bits).
              \item Address 1 points to the second word (next 8 bits).
          \end{itemize}
\end{itemize}

\subsection{Memory and C Programming}
In C, it is possible to access these memory addresses directly.
\begin{itemize}
    \item \textbf{Access:} You can obtain the address where a variable's value is stored.
    \item \textbf{Optimization:} This allows for low-level memory management and optimization of execution speed.
\end{itemize}

\separator

\section{Manage the memory with the command line:\\ free, top, htop}

To manage memory, we first need to see how much memory is used by the programs running on the Linux system.

\subsection{The free Command}
The \texttt{free} command displays the amount of free and used system memory.
\begin{itemize}
    \item \textbf{Options:} Use \texttt{-b} (bytes), \texttt{-k} (kilobytes), \texttt{-m} (megabytes), or \texttt{-g} (gigabytes) to set the unit.
    \item \textbf{Example:} \texttt{free -m} displays the table in megabytes.
    \item \textbf{Output:} The \texttt{Mem} line shows the total, used, and free memory.
\end{itemize}

\subsection{The top Command}
The \texttt{top} command shows memory usage per process.
\begin{itemize}
    \item \textbf{Statistics:} The header shows total used and free memory.
    \item \textbf{VSZ (Virtual Size):} Represents the virtual memory for each program (sometimes labeled \textbf{VIRT}).
    \item \textbf{Sorting:} Press the \textbf{M} key to sort processes by memory usage.
    \item \textbf{Visualization:} Pressing the \textbf{S} key (in this specific version) switches to a view showing only memory usage.
\end{itemize}

\subsection{The htop Command}
\texttt{htop} provides a visual representation of system resources.
\begin{itemize}
    \item \textbf{Visuals:} Bars indicate used and free memory.
    \item \textbf{Sorting:}
          \begin{enumerate}
              \item Press \textbf{F6} to select "Sort by".
              \item Select \textbf{M\_SIZE} (Memory Size) and press \textbf{Enter}.
              \item This sorts the list by the \textbf{VIRT} column.
          \end{enumerate}
\end{itemize}

Monitoring memory helps identify programs putting too much pressure on the system, which can then be killed if necessary.

\separator

\end{document}
