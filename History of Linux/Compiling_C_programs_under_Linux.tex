\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, mathtools}
\usepackage[table]{xcolor}
\usepackage{tikz}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{float}
\usepackage{parskip}
\usepackage{tabularx}
\usepackage[utf8]{inputenc}
\usepackage{tgpagella}
\usepackage[T1]{fontenc}
\usepackage{array}
\usepackage{booktabs}
\usepackage{tcolorbox}
\usepackage{enumitem}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{seqsplit}


\newcommand{\separator}{\noindent\rule{\linewidth}{1pt}}

\title{History of Linux and the command line}
\author{Zubin}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\newpage

\separator
%-----------------------------------------------------------------

\section{Compiler vs interpreter}

In the C programming language, we use a compiler. To understand the difference between an interpreter and a compiler, we can use an analogy of landing on a planet where inhabitants speak a strange language called "Gobbledygook". To get a mechanic to repair your spaceship, you need a translator.

\subsection{The Interpreter}
If you choose an interpreter:
\begin{itemize}
    \item \textbf{Process:} The interpreter reads your first instruction, translates it immediately, and the mechanic executes it. Then it reads the second, translates, and executes, and so on.
    \item \textbf{Characteristics:} The interpreter stays with you, translating line by line.
    \item \textbf{Pros:} It allows you to correct mistakes as you go (interactive).
    \item \textbf{Cons:} It is a slow process because the mechanic waits for translation between steps.
    \item \textbf{Etymology:} "Inter" means between. The interpreter is always between your program and the computer.
\end{itemize}

\subsection{The Compiler}
If you choose a compiler:
\begin{itemize}
    \item \textbf{Process:} The compiler takes your complete list of instructions and translates the whole lot at once. It then hands the translated list back to you and leaves.
    \item \textbf{Characteristics:} You hand the complete list to the mechanic, who executes them all in one go very quickly.
    \item \textbf{Pros:} Execution is very fast and efficient.
    \item \textbf{Cons:} Takes extra preparation time initially. If there is a mistake, it is too late to fix it during execution.
    \item \textbf{Etymology:} "Compile" means to pile together. It piles together your entire program and translates it all at once.
\end{itemize}

\subsection{Summary}
\begin{itemize}
    \item \textbf{Interpreter:} Runs slowly, starts right away, allows you to see how things are going.
    \item \textbf{Compiler:} Takes preparation time, but runs very quickly and efficiently.
\end{itemize}

\separator

\section{Memory representation:\\ RAM, cells, word, byte, bit, memory address}

How does the computer remember where it has stored the value for a certain variable? To answer this, we need to understand computer memory.

\subsection{Types of Memory}
One role of the operating system is to manage the computer's memory.
\begin{itemize}
    \item \textbf{RAM (Random Access Memory):} Temporary, volatile memory used to execute programs. It is quick to access.
    \item \textbf{Non-volatile Memory:} Permanent storage, such as the hard drive, used for storing files.
\end{itemize}

\subsection{Structure of RAM}
Most programs use RAM during execution.
\begin{itemize}
    \item \textbf{Bit:} A single binary memory cell (0 or 1).
    \item \textbf{Word:} A group of bits forming the fundamental unit of data moved between RAM and the processor.
    \item \textbf{Word Size:} The number of bits in a word (e.g., 8, 16, 32, 64 bits).
    \item \textbf{Byte:} A unit consisting of 8 bits.
\end{itemize}

\subsection{Memory Addressing}
To locate data, memory cells are grouped into words, and each word is assigned an address.
\begin{itemize}
    \item \textbf{Memory Address:} A whole number describing the location of a word in memory (similar to house addresses on a street).
    \item \textbf{Example:} If a computer has 8-bit words:
          \begin{itemize}
              \item Address 0 points to the first word (first 8 bits).
              \item Address 1 points to the second word (next 8 bits).
          \end{itemize}
\end{itemize}

\subsection{Memory and C Programming}
In C, it is possible to access these memory addresses directly.
\begin{itemize}
    \item \textbf{Access:} You can obtain the address where a variable's value is stored.
    \item \textbf{Optimization:} This allows for low-level memory management and optimization of execution speed.
\end{itemize}

\separator

\section{Manage the memory with the command line:\\ free, top, htop}

To manage memory, we first need to see how much memory is used by the programs running on the Linux system.

\subsection{The free Command}
The \texttt{free} command displays the amount of free and used system memory.
\begin{itemize}
    \item \textbf{Options:} Use \texttt{-b} (bytes), \texttt{-k} (kilobytes), \texttt{-m} (megabytes), or \texttt{-g} (gigabytes) to set the unit.
    \item \textbf{Example:} \texttt{free -m} displays the table in megabytes.
    \item \textbf{Output:} The \texttt{Mem} line shows the total, used, and free memory.
\end{itemize}

\subsection{The top Command}
The \texttt{top} command shows memory usage per process.
\begin{itemize}
    \item \textbf{Statistics:} The header shows total used and free memory.
    \item \textbf{VSZ (Virtual Size):} Represents the virtual memory for each program (sometimes labeled \textbf{VIRT}).
    \item \textbf{Sorting:} Press the \textbf{M} key to sort processes by memory usage.
    \item \textbf{Visualization:} Pressing the \textbf{S} key (in this specific version) switches to a view showing only memory usage.
\end{itemize}

\subsection{The htop Command}
\texttt{htop} provides a visual representation of system resources.
\begin{itemize}
    \item \textbf{Visuals:} Bars indicate used and free memory.
    \item \textbf{Sorting:}
          \begin{enumerate}
              \item Press \textbf{F6} to select "Sort by".
              \item Select \textbf{M\_SIZE} (Memory Size) and press \textbf{Enter}.
              \item This sorts the list by the \textbf{VIRT} column.
          \end{enumerate}
\end{itemize}

Monitoring memory helps identify programs putting too much pressure on the system, which can then be killed if necessary.

\separator

\section{Memory consumption of a program using htop, virtual memory}

We can analyze how much memory a C program uses by running it and monitoring it with \texttt{htop}. To do this effectively, the program must pause (e.g., waiting for user input via \texttt{scanf}) so it stays active in memory.

\subsection{Memory Usage by Data Type}
By declaring arrays of different types with one million elements, we can observe how memory consumption changes in the \texttt{VIRT} (Virtual Memory) column of \texttt{htop}:
\begin{itemize}
    \item \textbf{Basic Program:} A simple program might use $\approx$ 952 KB.
    \item \textbf{Char Array (1,000,000 chars):} Usage increases to $\approx$ 1,800 KB.
    \item \textbf{Int Array (1,000,000 ints):} Usage increases significantly to $\approx$ 4,728 KB (approx. 4 MB).
    \item \textbf{Double Array (1,000,000 doubles):} Usage doubles compared to integers, reaching $\approx$ 8,632 KB (approx. 8 MB).
\end{itemize}

\subsection{Virtual vs. Physical Memory}
An important observation is that even when a program reserves a large amount of memory (high \texttt{VIRT}), the system's physical memory usage (the bar at the top of \texttt{htop}) may not increase correspondingly.
\begin{itemize}
    \item \textbf{Virtual Memory:} The amount of memory the program has asked for or reserved.
    \item \textbf{Physical Memory:} The actual RAM hardware used.
    \item \textbf{Lazy Allocation:} Linux is smart; if a program reserves memory (like a large array) but never writes to or reads from it, the system does not immediately allocate physical RAM. Physical memory is consumed only when the virtual memory is actually used.
\end{itemize}

\subsection{Memory Management Tips}
\begin{itemize}
    \item \textbf{Optimization:} Ensure that large arrays or variables are used efficiently.
    \item \textbf{Dynamic Allocation:} If you allocate memory dynamically in C, always remember to \textbf{free} it to return it to the system for other programs.
\end{itemize}

\separator

\section{Interactive programs in C using scanf, fflush}

This section explains how to create interactive C programs and handle a common issue related to terminal output buffering.

\subsection{Basic Interactive Program with scanf}
An interactive program prompts the user for input and reads it from the terminal.
\begin{itemize}
    \item \textbf{Prompting:} Use \texttt{printf} to display a question to the user.
    \item \textbf{Reading Input:} Use \texttt{scanf} to wait for and read the user's input.
    \item \textbf{Example:} A program can ask for a family name, first name, and age.
          \begin{itemize}
              \item \texttt{scanf("\%s", familyName)} reads a string into a character array.
              \item \texttt{scanf("\%d", \&age)} reads an integer into an integer variable.
          \end{itemize}
    \item Typically, each prompt with \texttt{printf} ends with a newline character (\texttt{\textbackslash n}) to move the cursor to the next line for the user's input.
\end{itemize}

\subsection{The Problem of Buffered Output}
The \texttt{printf} function in C uses a buffer, which is a temporary memory area.
\begin{itemize}
    \item \textbf{Buffering:} Output is not always sent directly to the screen. It is first stored in a buffer. The buffer is "flushed" (its contents are sent to the terminal) when certain conditions are met.
    \item \textbf{Newline Trigger:} A common trigger for flushing the buffer is encountering a newline character (\texttt{\textbackslash n}).
    \item \textbf{The Issue:} If you write a \texttt{printf} statement for a prompt without a trailing \texttt{\textbackslash n}, the text may not appear on the screen immediately. The program might wait for the user's input with \texttt{scanf} before the prompt is even visible. All the buffered prompts might appear in a single line only after the program finishes or the buffer is flushed for another reason.
\end{itemize}

\subsection{The Solution: Flushing the Buffer with fflush}
To ensure prompts appear immediately without a newline, you can manually flush the output buffer.
\begin{itemize}
    \item \textbf{The Command:} The \texttt{fflush(stdout)} function forces the standard output buffer (\texttt{stdout}) to be written to the screen.
    \item \textbf{Implementation:} Place \texttt{fflush(stdout);} immediately after each \texttt{printf} statement that you want to appear on the screen right away.
    \item \textbf{Example:}
          \begin{tcolorbox}
              \texttt{printf("What is your first name? ");} \\
              \texttt{fflush(stdout);} \\
              \texttt{scanf("\%s", firstName);}
          \end{tcolorbox}
    \item This ensures the question is visible before the program waits for the \texttt{scanf} input, even without a \texttt{\textbackslash n}. The user's answer will then appear on the same line as the question.
\end{itemize}

\subsection{Important Considerations}
\begin{itemize}
    \item \textbf{System Variability:} This buffering behavior is not consistent across all Linux systems. Some systems or C libraries might flush output more frequently, even without a newline.
    \item \textbf{Best Practice:} To write portable and predictable interactive programs, always ensure the output buffer is flushed. The two main ways are:
          \begin{enumerate}
              \item End your prompt strings with \texttt{\textbackslash n}.
              \item Call \texttt{fflush(stdout);} after the prompt.
          \end{enumerate}
\end{itemize}

\separator

\section{Use scanf and file redirection to simulate an input}

We can automate or simulate user input for interactive programs using pipes and file redirection. This is useful for testing or when running programs in scripts.

\subsection{Creating an Input File}
First, create a file containing the inputs expected by the program, separated by newlines.
\begin{itemize}
    \item \textbf{Example:} Create a file named \texttt{answers} with the following content:
          \begin{tcolorbox}
              sharrock \\
              remi \\
              18
          \end{tcolorbox}
    \item You can create this using \texttt{nano} or \texttt{cat > answers}.
\end{itemize}

\subsection{Method 1: Using Pipes}
You can pipe the output of a command (like \texttt{cat}) into your program.
\begin{itemize}
    \item \textbf{Command:} \texttt{cat answers | ./program}
    \item \textbf{Explanation:} The shell takes the output of \texttt{cat answers} and feeds it as standard input to \texttt{./program}. The \texttt{scanf} functions in the program read from this stream just as if it were typed on the keyboard.
\end{itemize}

\subsection{Method 2: Input Redirection}
You can redirect a file directly into the program's standard input using the less-than sign (\texttt{<}).
\begin{itemize}
    \item \textbf{Command:} \texttt{./program < answers}
    \item \textbf{Explanation:} This tells the shell to open the file \texttt{answers} and connect it to the input of \texttt{./program}.
    \item \textbf{Note:} This is the reverse of output redirection (\texttt{>}), which sends output to a file. Here, we send a file to the input.
\end{itemize}

\separator

\section{Donâ€™t use scanf, use fgets getline or readline}

Using \texttt{scanf} for string input can be dangerous and lead to unexpected behavior for both programmers and users.

\subsection{The Problem with scanf}
\texttt{scanf} splits input based on whitespace (spaces, tabs, newlines).
\begin{itemize}
    \item \textbf{Scenario:} A program asks for Family Name, First Name, and Age sequentially.
    \item \textbf{Input:} If the user types "Sharrock Remi 18" at the first prompt and hits Enter.
    \item \textbf{Result:}
          \begin{itemize}
              \item Family Name becomes "Sharrock".
              \item First Name automatically becomes "Remi" (consuming the next part of the buffer).
              \item Age automatically becomes "18".
          \end{itemize}
    \item The program skips waiting for the subsequent inputs because \texttt{scanf} consumed the space-separated values from the first line. This behavior makes \texttt{scanf} risky for robust user interaction.
\end{itemize}

\subsection{Better Alternatives}
To handle string input more safely, consider these functions:
\begin{itemize}
    \item \textbf{fgets:} Reads the entire line, including spaces. Note that it also captures the newline character (\texttt{\textbackslash n}) at the end, which you may need to remove.
    \item \textbf{getline:} A POSIX-standard function (available on most Unix-like systems) that reads an entire line.
    \item \textbf{GNU readline:} A powerful function specific to Linux/GNU systems.
\end{itemize}

For robust C programming, it is recommended to research these functions or take a dedicated C programming course.

\separator
\separator

\section{Use the math library}

\subsection{Using the pow function}
We can use the math library to perform calculations, such as finding the square of a number, instead of writing our own function. The \texttt{pow} function calculates a number raised to the power of another.
\begin{itemize}
    \item \textbf{Prototype:} Also known as the declaration, header, or signature. It defines the return type, function name, and parameter types.
    \item \textbf{Example:} \texttt{double pow(double x, double y);}
    \item \textbf{Usage:} \texttt{pow(a, 2)} calculates $a^2$.
\end{itemize}
To use this function, we need to link our program to the binary file containing its definition.

\subsection{Locating the Library Binary}
Compiled library files are typically stored in \texttt{/usr/lib}.
\begin{itemize}
    \item The math library is often named \texttt{libm.a} (archive) or \texttt{libm.so} (shared object).
    \item \textbf{Linking with Absolute Path:} You can compile by specifying the full path to the library:
          \begin{tcolorbox}
              \texttt{gcc program.c /usr/lib/libm.a -o program}
          \end{tcolorbox}
\end{itemize}

\subsection{Header Files}
Header files, which contain function prototypes, are located in \texttt{/usr/include}.
\begin{itemize}
    \item The header for the math library is \texttt{math.h}.
    \item \textbf{Including the Header:} Instead of typing the prototype manually, use the \texttt{\#include} directive at the top of your C file. This copies the content of the header file into your program.
          \begin{tcolorbox}
              \texttt{\#include <math.h>}
          \end{tcolorbox}
\end{itemize}

\subsection{Linking with the -l Option}
A more common and convenient way to link libraries is using the \texttt{-l} flag.
\begin{itemize}
    \item \textbf{Naming Convention:} To derive the flag, take the library name (e.g., \texttt{libm.a}), remove the \texttt{lib} prefix and the file extension.
    \item \textbf{Example:} \texttt{libm.a} becomes \texttt{m}.
    \item \textbf{Command:}
          \begin{tcolorbox}
              \texttt{gcc program.c -lm -o program}
          \end{tcolorbox}
\end{itemize}

\separator

\section{Use multiple libraries in C}

We will now look at a program that uses several external libraries. This requires including header files (definitions and prototypes) and linking object files (compiled code).

\subsection{Locating Headers and Libraries}
To find the necessary files on the system:
\begin{itemize}
    \item \textbf{Header Files:} Located in \texttt{/usr/include}. We can list them to a file: \texttt{ls /usr/include > headers.txt}.
          \begin{itemize}
              \item \texttt{curses.h}: Allows cursor manipulation and colors.
              \item \texttt{menu.h}: Allows creation of menus.
          \end{itemize}
    \item \textbf{Object Files:} Located in \texttt{/usr/lib}. We can list them: \texttt{ls /usr/lib > libraries.txt}.
          \begin{itemize}
              \item \texttt{libcurses.so}: The compiled code for curses.
              \item \texttt{libmenu.so}: The compiled code for menus.
          \end{itemize}
\end{itemize}

\subsection{Including Headers}
In the C program, we must include the headers for the functions we are using:
\begin{tcolorbox}
    \texttt{\#include <curses.h>} \\
    \texttt{\#include <menu.h>} \\
    \texttt{\#include <stdlib.h>}
\end{tcolorbox}
Note: \texttt{stdlib.h} is included because the program uses \texttt{calloc} for memory allocation.

\subsection{Linking Libraries}
To include the actual code for the functions, we must link the libraries during the build process.

\subsubsection{Method 1: Absolute Path}
Add the exact path to the library on the build line:
\begin{tcolorbox}
    \texttt{gcc program.c /usr/lib/libcurses.so /usr/lib/libmenu.so -o program}
\end{tcolorbox}
The standard library (\texttt{stdlib}) is automatically linked, so it does not need to be added here.

\subsubsection{Method 2: Using the -l Flag}
A more convenient way is to use the \texttt{-l} flag followed by the library name (without "lib" or extension):
\begin{tcolorbox}
    \texttt{gcc program.c -lcurses -lmenu -o program}
\end{tcolorbox}

\separator
\section{GCC details}

In this section, we explain the details of the build command and the steps performed by the compiler (GCC) to turn C source code into an executable program.

\subsection{The Build Command and Flags}
When you press the "Run It" button in WebLinux, or build manually, a command like this is executed:
\begin{tcolorbox}
    \texttt{gcc -std=C11 -Wall -fmax-errors=10 -Wextra -o program program.c}
\end{tcolorbox}

Here is a breakdown of the flags used:
\begin{itemize}
    \item \textbf{-std=C11}: Specifies the C standard to use. C11 is a modern standard.
    \item \textbf{-Wall}: Displays all warnings. It is important to look at these and fix them, as they often indicate errors.
    \item \textbf{-fmax-errors=10}: Tells the compiler to stop after 10 errors so the user is not overwhelmed.
    \item \textbf{-Wextra}: Enables extra warnings that are not included in \texttt{-Wall}.
    \item \textbf{-o program}: Specifies the name of the output file (the executable). If this flag is omitted, GCC creates an executable named \texttt{a.out} by default.
\end{itemize}

\subsection{Compilation Stages}
When you run GCC, it performs three main steps: preprocessing, compilation, and linking. We can invoke these steps separately.

\subsubsection{1. The Preprocessor}
The preprocessor performs simple textual replacement. For example, it finds the contents of header files (like \texttt{stdio.h}) and copies them verbatim into the source code.

\subsubsection{2. Compilation (Translation)}
This step translates the source code into machine language, creating a so-called \textbf{object file}.
\begin{itemize}
    \item To perform only this step, use the \texttt{-c} flag.
    \item \textbf{Command:} \texttt{gcc -c program.c -o program.o}
    \item This creates \texttt{program.o}. It is the binary, computer-readable version of the code, but it cannot be executed directly (it lacks system libraries).
\end{itemize}

\subsubsection{3. The Linker}
The linker bundles the object file with necessary system libraries to produce the final executable.
\begin{itemize}
    \item \textbf{Command:} \texttt{gcc program.o -o program}
    \item This takes the object file \texttt{program.o} and creates the executable \texttt{program}, which can be run with \texttt{./program}.
\end{itemize}

Understanding these steps is essential for separate compilation, where source code is split across multiple files.

\separator

\section{Object files}

In this section, we demonstrate \textbf{separate compilation}, which means spreading source code over several files and assembling them into one final executable. This is essential for organizing large programs by topic.

\subsection{Creating Separate Files}
We separate the \texttt{average\_temperature} function from the main program into its own file.
\begin{itemize}
    \item \textbf{weatherstats.c}: Contains the source code for the \texttt{average\_temperature} function.
    \item \textbf{weatherstats.h}: A header file containing the function prototype.
    \item \textbf{program.c}: Contains the \texttt{main} function.
\end{itemize}

To use the function in \texttt{program.c}, we must include the header.
\begin{tcolorbox}
    \texttt{\#include "weatherstats.h"}
\end{tcolorbox}
\textbf{Note:} We use quotation marks (\texttt{""}) instead of angle brackets (\texttt{<>}). Angle brackets tell the compiler to look in standard system paths (like \texttt{/usr/include}), whereas quotation marks tell it to look in the current directory.

\subsection{Compiling Object Files}
We compile each source file into an object file (\texttt{.o}) individually.

\subsubsection{Compiling the Module}
\begin{tcolorbox}
    \texttt{gcc -c weatherstats.c -o weatherstats.o}
\end{tcolorbox}
We must use the \texttt{-c} flag. If omitted, GCC tries to build an executable and fails because \texttt{weatherstats.c} has no \texttt{main} function.

\subsubsection{Compiling the Main Program}
\begin{tcolorbox}
    \texttt{gcc -Wall -c program.c -o program.o}
\end{tcolorbox}
Using \texttt{-Wall} ensures we see warnings, such as "implicitly declared function" if we forget to include the header file.

\subsection{Linking}
Finally, we invoke the linker to bundle the object files into an executable.
\begin{tcolorbox}
    \texttt{gcc -o program program.o weatherstats.o}
\end{tcolorbox}
This creates the final executable \texttt{program} by combining the machine language from both object files.

\separator

\section{Modify object files}

To reinforce what we have learned so far about spreading source code over multiple files, compiling, and linking, we will walk through the steps required to modify this code. You will see that these steps can become tedious, which motivates the use of \textbf{Makefiles} (covered in the next topic) to automate the process.

Suppose we want to add a maximum temperature feature to our \texttt{weatherstats} source file and call it from the main program.

\subsection{Modifying the Source Code}

\subsubsection{Updating the Main Program}
In \texttt{program.c}, we add a call to the new function and print the result.
\begin{tcolorbox}
    \texttt{double max = maxTemp(temperatures, 7);} \\
    \texttt{printf("Highest temp: \%.2lf\textbackslash n", max);}
\end{tcolorbox}

\subsubsection{Updating the Module}
We add the \texttt{maxTemp} function to \texttt{weatherstats.c}.
\begin{tcolorbox}
    \texttt{double maxTemp(double *temperatures, int size) \{} \\
    \texttt{    double max = temperatures[0];} \\
    \texttt{    int i;} \\
    \texttt{    for (i = 1; i < size; i++) \{} \\
    \texttt{        if (max < temperatures[i]) \{} \\
    \texttt{            max = temperatures[i];} \\
    \texttt{        \}} \\
    \texttt{    \}} \\
    \texttt{    return max;} \\
    \texttt{\}}
\end{tcolorbox}

\subsubsection{Updating the Header}
We must add the function prototype to \texttt{weatherstats.h} so the compiler knows about it when compiling \texttt{program.c}.
\begin{tcolorbox}
    \texttt{double maxTemp(double *temperatures, int size);}
\end{tcolorbox}

\subsection{Compiling and Linking}
Now we must translate the code into machine language.

\begin{enumerate}
    \item \textbf{Compile program.c:}
          \begin{tcolorbox}
              \texttt{gcc -Wall -c program.c -o program.o}
          \end{tcolorbox}
    \item \textbf{Compile weatherstats.c:}
          \begin{tcolorbox}
              \texttt{gcc -Wall -c weatherstats.c -o weatherstats.o}
          \end{tcolorbox}
    \item \textbf{Link them together:}
          \begin{tcolorbox}
              \texttt{gcc -o program program.o weatherstats.o}
          \end{tcolorbox}
\end{enumerate}
Running \texttt{./program} will now display both the average and the maximum temperature.

\subsection{Partial Recompilation}
If we modify only one file, we do not need to recompile everything. For example, if we change a temperature value (e.g., changing 5.3 to 15.3) in \texttt{program.c}:
\begin{enumerate}
    \item \textbf{Recompile only the changed file:}
          \begin{tcolorbox}
              \texttt{gcc -Wall -c program.c -o program.o}
          \end{tcolorbox}
          We do not need to recompile \texttt{weatherstats.c} since it hasn't changed.
    \item \textbf{Relink:}
          \begin{tcolorbox}
              \texttt{gcc -o program program.o weatherstats.o}
          \end{tcolorbox}
\end{enumerate}
When we run the program now, we get the updated result. As you can see, making modifications to source code spread out over multiple files can be rather tedious, which is why we will look at Makefiles next.

\separator

\section{Make file}

We will now see how to automate all of the necessary steps to build the final executable program from source code spread out over multiple files. We will use the \texttt{make} program, which reads instructions from a file named \texttt{Makefile}.

\subsection{The Makefile Structure}
To use \texttt{make}, we create a file named \texttt{Makefile}. The structure of the rules in this file is specific:
\begin{tcolorbox}
    \texttt{target: dependencies} \\
    \texttt{\hspace*{1cm} command}
\end{tcolorbox}
\textbf{Note:} The indentation before the command must be a \textbf{tab} character, not spaces.

\begin{itemize}
    \item \textbf{Target:} What is to be produced.
    \item \textbf{Dependencies:} What is needed to produce the target.
    \item \textbf{Command:} How to produce the target.
\end{itemize}

\subsection{Constructing the Makefile}
We define the targets for our weather statistics program.

\subsubsection{The Executable}
The final target is the executable \texttt{program}. It depends on the object files.
\begin{tcolorbox}
    \texttt{program: program.o weatherstats.o} \\
    \texttt{\hspace*{1cm} gcc -std=C11 -Wall -fmax-errors=10 -Wextra -o program program.o weatherstats.o}
\end{tcolorbox}

\subsubsection{The Object Files}
We also need to tell \texttt{make} how to build the object files.
\begin{itemize}
    \item \textbf{program.o:} Depends on \texttt{program.c} and \texttt{weatherstats.h}.
          \begin{tcolorbox}
              \texttt{program.o: program.c weatherstats.h} \\
              \texttt{\hspace*{1cm} gcc -std=C11 -Wall -fmax-errors=10 -Wextra -c program.c -o program.o}
          \end{tcolorbox}
    \item \textbf{weatherstats.o:} Depends on \texttt{weatherstats.c}.
          \begin{tcolorbox}
              \texttt{weatherstats.o: weatherstats.c} \\
              \texttt{\hspace*{1cm} gcc -std=C11 -Wall -fmax-errors=10 -Wextra -c weatherstats.c -o weatherstats.o}
          \end{tcolorbox}
\end{itemize}

\subsection{Running Make}
To build the program, simply type \texttt{make} in the terminal.
\begin{tcolorbox}
    \texttt{\$ make}
\end{tcolorbox}
This will execute the necessary commands to build the targets.

\subsection{Efficiency}
The \texttt{make} program is smart and only recompiles what is necessary.
\begin{itemize}
    \item If you modify \texttt{program.c} but not \texttt{weatherstats.c}, running \texttt{make} will only recompile \texttt{program.o} and then link the program. It will not recompile \texttt{weatherstats.o}.
    \item If you run \texttt{make} when everything is up to date, it will do nothing.
\end{itemize}
This automation simplifies the build process significantly.

\separator

\section{More elaborate Makefile}

I want to quickly show you an alternative \texttt{Makefile}, one that is more versatile towards making changes and can be more broadly used for other purposes. This is an optional extra topic, but if you look on the internet for Makefiles, you will most likely see something that is more like the one shown here.

\subsection{Variables and Comments}
In this Makefile, we use variables to define settings at the top of the file. This makes it easy to change compilers, flags, or file names without modifying the logic below.
\begin{itemize}
    \item \textbf{Comments:} Anything starting with a pound sign (\texttt{\#}) is a comment.
    \item \textbf{CC:} Defines the compiler (e.g., \texttt{gcc}).
    \item \textbf{CFLAGS:} Defines the compiler flags.
    \item \textbf{OBJ:} Lists the object files needed for the project.
    \item \textbf{MAIN:} Defines the name of the final executable.
\end{itemize}

\subsection{Generic Rules}
The targets use these variables.
\begin{itemize}
    \item \textbf{all:} The default target, which depends on the executable variable \texttt{\$(MAIN)}.
    \item \textbf{\$(MAIN):} Depends on the object files \texttt{\$(OBJ)}. It uses the variables to construct the link command.
    \item \textbf{\%.o: \%.c:} A generic rule to compile any \texttt{.c} file into a \texttt{.o} file.
          \begin{itemize}
              \item \texttt{\$<}: Refers to the source file (the dependency).
              \item \texttt{\$@}: Refers to the output file (the target).
          \end{itemize}
\end{itemize}

\subsection{The Clean Target}
A \texttt{clean} target is added to remove object files and the executable, allowing for a fresh build.

\subsection{Example Code}
Here is the complete elaborate \texttt{Makefile}:

\begin{tcolorbox}
    \texttt{\# Define the compiler} \\
    \texttt{CC = gcc} \\
    \texttt{\# Define compiler flags} \\
    \texttt{CFLAGS = -std=c11 -Wall -fmax-errors=10 -Wextra} \\
    \texttt{} \\
    \texttt{\# Define object files} \\
    \texttt{OBJ = program.o weatherstats.o} \\
    \texttt{\# Define the executable name} \\
    \texttt{MAIN = program} \\
    \texttt{} \\
    \texttt{all: \$(MAIN)} \\
    \texttt{} \\
    \texttt{\$(MAIN): \$(OBJ)} \\
    \texttt{\hspace*{1cm} \$(CC) \$(CFLAGS) -o \$(MAIN) \$(OBJ)} \\
    \texttt{} \\
    \texttt{\# Generic rule for compiling .c to .o} \\
    \texttt{\%.o: \%.c} \\
    \texttt{\hspace*{1cm} \$(CC) \$(CFLAGS) -c \$< -o \$@} \\
    \texttt{} \\
    \texttt{clean:} \\
    \texttt{\hspace*{1cm} rm *.o \$(MAIN)}
\end{tcolorbox}

Running \texttt{make} will execute the steps defined by these generic rules. Running \texttt{make clean} will remove the generated files.

\separator

\section{Create your library}

We are finally ready to create our own libraries. Libraries typically consist of a number of object files bundled together into an archive.

\subsection{Static Libraries}
A static library is an archive of object files, typically with the extension \texttt{.a} on Linux. The linker extracts only the necessary functions from the archive and copies them into the executable.

\subsubsection{Creating a Static Library}
\begin{enumerate}
    \item \textbf{Compile the module:} Compile the source files into object files.
          \begin{tcolorbox}
              \texttt{gcc -c weatherstats.c -o weatherstats.o}
          \end{tcolorbox}
    \item \textbf{Create the archive:} Use the \texttt{ar} command to bundle the object files.
          \begin{tcolorbox}
              \texttt{ar rcs libweather.a weatherstats.o}
          \end{tcolorbox}
          \begin{itemize}
              \item \textbf{r (replace):} Replaces existing files in the archive.
              \item \textbf{c (create):} Creates the archive if it does not exist.
              \item \textbf{s (index):} Creates an index for faster access.
              \item \textbf{Naming Convention:} Libraries typically start with \texttt{lib} and end with \texttt{.a} (e.g., \texttt{libweather.a}).
          \end{itemize}
\end{enumerate}

\subsubsection{Linking a Static Library}
There are two ways to link the library to your main program.

\textbf{Method 1: Direct File Path}
\begin{tcolorbox}
    \texttt{gcc -o program program.o libweather.a}
\end{tcolorbox}

\textbf{Method 2: Using -l and -L flags}
\begin{tcolorbox}
    \texttt{gcc -o program program.o -L. -lweather}
\end{tcolorbox}
\begin{itemize}
    \item \textbf{-lweather:} Links the library named \texttt{weather}. GCC automatically expands this to \texttt{libweather.a}.
    \item \textbf{-L.:} Adds the current directory (\texttt{.}) to the library search path. Without this, GCC only looks in standard system directories.
\end{itemize}

\subsection{Dynamic (Shared) Libraries}
Dynamic libraries (Shared Objects) have the extension \texttt{.so} on Linux (or \texttt{.dll} on Windows).
\subsubsection{Static vs. Dynamic Libraries difference Table}
\begin{table}[h!]
    \centering
    \renewcommand{\arraystretch}{1.3}
    \begin{tabular}{|p{7cm}|p{7cm}|}
        \hline
        \multicolumn{2}{|c|}{\textbf{Static Versus Dynamic Libraries in C}}                                                                                      \\
        \hline
        \textbf{Static}                                                                                                                       & \textbf{Dynamic} \\
        \hline
        Linker finds all used library functions (such as \texttt{printf()}, \texttt{sqrt()}, etc.) and copies them into your executable file. &
        Linked dynamically at run-time by the OS; every program that accesses the library uses the same copy.                                                    \\
        \hline
        Libraries have the extension \texttt{.a} (Linux) or \texttt{.lib} (Windows).                                                          &
        Libraries have the extension \texttt{.so} (Linux) or \texttt{.dll} (Windows).                                                                            \\
        \hline
        Executable is a larger file, needing more disk space and main memory.                                                                 &
        Executable only contains the name of (a link to) the library.                                                                                            \\
        \hline
        If the library changes, the executable does not automatically update and needs to be re-linked.                                       &
        If the library changes, the executable will automatically use the new library code.                                                                      \\
        \hline
        If the library becomes incompatible with your code, your executable will still run as long as you do not re-link.                     &
        If the library becomes incompatible with your code, your executable will no longer run.                                                                  \\
        \hline
        Library access is faster.                                                                                                             &
        Dynamic querying of symbols takes time.                                                                                                                  \\
        \hline
    \end{tabular}
    \caption{Comparison of Static and Dynamic Libraries in C}
\end{table}
\subsubsection{Static vs. Dynamic Libraries}
\begin{itemize}
    \item \textbf{Static (.a):}
          \begin{itemize}
              \item \textbf{Linking:} Code is copied into the executable.
              \item \textbf{Size:} Executable is larger.
              \item \textbf{Memory:} Uses more memory if multiple programs use the same library (each has its own copy).
              \item \textbf{Updates:} Executable must be recompiled to use updated library code.
              \item \textbf{Speed:} Faster execution.
          \end{itemize}
    \item \textbf{Dynamic (.so):}
          \begin{itemize}
              \item \textbf{Linking:} Code is linked at runtime. The executable contains only references.
              \item \textbf{Size:} Executable is smaller.
              \item \textbf{Memory:} Efficient; one copy of the library in memory is shared by multiple programs.
              \item \textbf{Updates:} Executable automatically uses the updated library (unless incompatible).
              \item \textbf{Speed:} Slightly slower due to dynamic symbol lookup.
          \end{itemize}
\end{itemize}


\subsubsection{Creating a Dynamic Library}
\begin{enumerate}
    \item \textbf{Compile with PIC:} Use the \texttt{-fpic} (Position Independent Code) flag.
          \begin{tcolorbox}
              \texttt{gcc -c -fpic weatherstats.c -o weatherstats.o}
          \end{tcolorbox}
    \item \textbf{Create the Shared Object:} Use \texttt{gcc} with the \texttt{-shared} flag.
          \begin{tcolorbox}
              \texttt{gcc -shared -o libweather.so weatherstats.o}
          \end{tcolorbox}
\end{enumerate}

\subsubsection{Linking and Running}
Linking uses the same command as static libraries:
\begin{tcolorbox}
    \texttt{gcc -o program program.o -L. -lweather}
\end{tcolorbox}

However, to run the program, the operating system must be able to find the shared library. You may need to update the \texttt{LD\_LIBRARY\_PATH} environment variable:
\begin{tcolorbox}
    \texttt{export LD\_LIBRARY\_PATH=\$LD\_LIBRARY\_PATH:\$PWD} \\
    \texttt{./program}
\end{tcolorbox}

\separator
\begin{table}[h!]
    \centering
    \renewcommand{\arraystretch}{1.4}
    \setlength{\tabcolsep}{6pt}

    % Color definitions
    \definecolor{headerblue}{RGB}{63,114,195}
    \definecolor{rowblue}{RGB}{225,232,246}

    \begin{tabular}{|p{3.5cm}|p{6.2cm}|p{6.2cm}|}
        \hline
        \rowcolor{headerblue}
        \multicolumn{3}{|c|}{\textcolor{white}{\textbf{Static Versus Dynamic Libraries in C (Linux OS)}}} \\
        \hline
        \rowcolor{headerblue}
        \textcolor{white}{\textbf{Library}} &
        \textcolor{white}{\textbf{Static}}  &
        \textcolor{white}{\textbf{Dynamic}}                                                               \\
        \hline

        \rowcolor{rowblue}
        Compile library files               &
        \texttt{gcc -c part1.c -o part1.o} \newline
        \texttt{gcc -c part2.c -o part2.o} \newline
        \texttt{...}
                                            &
        \texttt{gcc -c -fpic part1.c -o part1.o} \newline
        \texttt{gcc -c -fpic part2.c -o part2.o} \newline
        \texttt{...}
        \\
        \hline

        Create library                      &
        \texttt{ar rcs libmylib.a part1.o part2.o ...}
                                            &
        \texttt{gcc -shared -o libmylib.so part1.o part2.o ...}
        \\
        \hline

        \rowcolor{rowblue}
        Compile main program                &
        \texttt{gcc -c program.c -o program.o}
                                            &
        \texttt{gcc -c program.c -o program.o}
        \\
        \hline

        Link library to main program        &
        \texttt{gcc -o program program.o -L. -lmylib}
                                            &
        \texttt{gcc -o program program.o -L. -lmylib} \newline
        Add library path to environment variable: \newline
        \texttt{\seqsplit{export:\ LD\_LIBRARY\_PATH=\$PWD:\$LD\_LIBRARY\_PATH}}
        \\
        \hline

        \rowcolor{rowblue}
        Run program                         &
        \texttt{./program}
                                            &
        \texttt{./program}
        \\
        \hline
    \end{tabular}

    \caption{Steps to create and use static and dynamic libraries in C on Linux}
\end{table}


\end{document}
