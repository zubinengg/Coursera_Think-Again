\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, mathtools}
\usepackage{tikz}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{float}
\usepackage{parskip}
\usepackage{tabularx}
\usepackage[utf8]{inputenc}
\usepackage{tgpagella}
\usepackage[T1]{fontenc}
\usepackage{array}
\usepackage{booktabs}
\usepackage{tcolorbox}
\usepackage{enumitem}

\newcommand{\separator}{\noindent\rule{\linewidth}{1pt}}

\title{History of Linux and the command line}
\author{Zubin}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\newpage

\separator
%-----------------------------------------------------------------

\section{Compiler vs interpreter}

In the C programming language, we use a compiler. To understand the difference between an interpreter and a compiler, we can use an analogy of landing on a planet where inhabitants speak a strange language called "Gobbledygook". To get a mechanic to repair your spaceship, you need a translator.

\subsection{The Interpreter}
If you choose an interpreter:
\begin{itemize}
    \item \textbf{Process:} The interpreter reads your first instruction, translates it immediately, and the mechanic executes it. Then it reads the second, translates, and executes, and so on.
    \item \textbf{Characteristics:} The interpreter stays with you, translating line by line.
    \item \textbf{Pros:} It allows you to correct mistakes as you go (interactive).
    \item \textbf{Cons:} It is a slow process because the mechanic waits for translation between steps.
    \item \textbf{Etymology:} "Inter" means between. The interpreter is always between your program and the computer.
\end{itemize}

\subsection{The Compiler}
If you choose a compiler:
\begin{itemize}
    \item \textbf{Process:} The compiler takes your complete list of instructions and translates the whole lot at once. It then hands the translated list back to you and leaves.
    \item \textbf{Characteristics:} You hand the complete list to the mechanic, who executes them all in one go very quickly.
    \item \textbf{Pros:} Execution is very fast and efficient.
    \item \textbf{Cons:} Takes extra preparation time initially. If there is a mistake, it is too late to fix it during execution.
    \item \textbf{Etymology:} "Compile" means to pile together. It piles together your entire program and translates it all at once.
\end{itemize}

\subsection{Summary}
\begin{itemize}
    \item \textbf{Interpreter:} Runs slowly, starts right away, allows you to see how things are going.
    \item \textbf{Compiler:} Takes preparation time, but runs very quickly and efficiently.
\end{itemize}

\separator

\section{Memory representation:\\ RAM, cells, word, byte, bit, memory address}

How does the computer remember where it has stored the value for a certain variable? To answer this, we need to understand computer memory.

\subsection{Types of Memory}
One role of the operating system is to manage the computer's memory.
\begin{itemize}
    \item \textbf{RAM (Random Access Memory):} Temporary, volatile memory used to execute programs. It is quick to access.
    \item \textbf{Non-volatile Memory:} Permanent storage, such as the hard drive, used for storing files.
\end{itemize}

\subsection{Structure of RAM}
Most programs use RAM during execution.
\begin{itemize}
    \item \textbf{Bit:} A single binary memory cell (0 or 1).
    \item \textbf{Word:} A group of bits forming the fundamental unit of data moved between RAM and the processor.
    \item \textbf{Word Size:} The number of bits in a word (e.g., 8, 16, 32, 64 bits).
    \item \textbf{Byte:} A unit consisting of 8 bits.
\end{itemize}

\subsection{Memory Addressing}
To locate data, memory cells are grouped into words, and each word is assigned an address.
\begin{itemize}
    \item \textbf{Memory Address:} A whole number describing the location of a word in memory (similar to house addresses on a street).
    \item \textbf{Example:} If a computer has 8-bit words:
          \begin{itemize}
              \item Address 0 points to the first word (first 8 bits).
              \item Address 1 points to the second word (next 8 bits).
          \end{itemize}
\end{itemize}

\subsection{Memory and C Programming}
In C, it is possible to access these memory addresses directly.
\begin{itemize}
    \item \textbf{Access:} You can obtain the address where a variable's value is stored.
    \item \textbf{Optimization:} This allows for low-level memory management and optimization of execution speed.
\end{itemize}

\separator

\section{Manage the memory with the command line:\\ free, top, htop}

To manage memory, we first need to see how much memory is used by the programs running on the Linux system.

\subsection{The free Command}
The \texttt{free} command displays the amount of free and used system memory.
\begin{itemize}
    \item \textbf{Options:} Use \texttt{-b} (bytes), \texttt{-k} (kilobytes), \texttt{-m} (megabytes), or \texttt{-g} (gigabytes) to set the unit.
    \item \textbf{Example:} \texttt{free -m} displays the table in megabytes.
    \item \textbf{Output:} The \texttt{Mem} line shows the total, used, and free memory.
\end{itemize}

\subsection{The top Command}
The \texttt{top} command shows memory usage per process.
\begin{itemize}
    \item \textbf{Statistics:} The header shows total used and free memory.
    \item \textbf{VSZ (Virtual Size):} Represents the virtual memory for each program (sometimes labeled \textbf{VIRT}).
    \item \textbf{Sorting:} Press the \textbf{M} key to sort processes by memory usage.
    \item \textbf{Visualization:} Pressing the \textbf{S} key (in this specific version) switches to a view showing only memory usage.
\end{itemize}

\subsection{The htop Command}
\texttt{htop} provides a visual representation of system resources.
\begin{itemize}
    \item \textbf{Visuals:} Bars indicate used and free memory.
    \item \textbf{Sorting:}
          \begin{enumerate}
              \item Press \textbf{F6} to select "Sort by".
              \item Select \textbf{M\_SIZE} (Memory Size) and press \textbf{Enter}.
              \item This sorts the list by the \textbf{VIRT} column.
          \end{enumerate}
\end{itemize}

Monitoring memory helps identify programs putting too much pressure on the system, which can then be killed if necessary.

\separator

\section{Memory consumption of a program using htop, virtual memory}

We can analyze how much memory a C program uses by running it and monitoring it with \texttt{htop}. To do this effectively, the program must pause (e.g., waiting for user input via \texttt{scanf}) so it stays active in memory.

\subsection{Memory Usage by Data Type}
By declaring arrays of different types with one million elements, we can observe how memory consumption changes in the \texttt{VIRT} (Virtual Memory) column of \texttt{htop}:
\begin{itemize}
    \item \textbf{Basic Program:} A simple program might use $\approx$ 952 KB.
    \item \textbf{Char Array (1,000,000 chars):} Usage increases to $\approx$ 1,800 KB.
    \item \textbf{Int Array (1,000,000 ints):} Usage increases significantly to $\approx$ 4,728 KB (approx. 4 MB).
    \item \textbf{Double Array (1,000,000 doubles):} Usage doubles compared to integers, reaching $\approx$ 8,632 KB (approx. 8 MB).
\end{itemize}

\subsection{Virtual vs. Physical Memory}
An important observation is that even when a program reserves a large amount of memory (high \texttt{VIRT}), the system's physical memory usage (the bar at the top of \texttt{htop}) may not increase correspondingly.
\begin{itemize}
    \item \textbf{Virtual Memory:} The amount of memory the program has asked for or reserved.
    \item \textbf{Physical Memory:} The actual RAM hardware used.
    \item \textbf{Lazy Allocation:} Linux is smart; if a program reserves memory (like a large array) but never writes to or reads from it, the system does not immediately allocate physical RAM. Physical memory is consumed only when the virtual memory is actually used.
\end{itemize}

\subsection{Memory Management Tips}
\begin{itemize}
    \item \textbf{Optimization:} Ensure that large arrays or variables are used efficiently.
    \item \textbf{Dynamic Allocation:} If you allocate memory dynamically in C, always remember to \textbf{free} it to return it to the system for other programs.
\end{itemize}

\separator

\section{Interactive programs in C using scanf, fflush}

This section explains how to create interactive C programs and handle a common issue related to terminal output buffering.

\subsection{Basic Interactive Program with scanf}
An interactive program prompts the user for input and reads it from the terminal.
\begin{itemize}
    \item \textbf{Prompting:} Use \texttt{printf} to display a question to the user.
    \item \textbf{Reading Input:} Use \texttt{scanf} to wait for and read the user's input.
    \item \textbf{Example:} A program can ask for a family name, first name, and age.
          \begin{itemize}
              \item \texttt{scanf("\%s", familyName)} reads a string into a character array.
              \item \texttt{scanf("\%d", \&age)} reads an integer into an integer variable.
          \end{itemize}
    \item Typically, each prompt with \texttt{printf} ends with a newline character (\texttt{\textbackslash n}) to move the cursor to the next line for the user's input.
\end{itemize}

\subsection{The Problem of Buffered Output}
The \texttt{printf} function in C uses a buffer, which is a temporary memory area.
\begin{itemize}
    \item \textbf{Buffering:} Output is not always sent directly to the screen. It is first stored in a buffer. The buffer is "flushed" (its contents are sent to the terminal) when certain conditions are met.
    \item \textbf{Newline Trigger:} A common trigger for flushing the buffer is encountering a newline character (\texttt{\textbackslash n}).
    \item \textbf{The Issue:} If you write a \texttt{printf} statement for a prompt without a trailing \texttt{\textbackslash n}, the text may not appear on the screen immediately. The program might wait for the user's input with \texttt{scanf} before the prompt is even visible. All the buffered prompts might appear in a single line only after the program finishes or the buffer is flushed for another reason.
\end{itemize}

\subsection{The Solution: Flushing the Buffer with fflush}
To ensure prompts appear immediately without a newline, you can manually flush the output buffer.
\begin{itemize}
    \item \textbf{The Command:} The \texttt{fflush(stdout)} function forces the standard output buffer (\texttt{stdout}) to be written to the screen.
    \item \textbf{Implementation:} Place \texttt{fflush(stdout);} immediately after each \texttt{printf} statement that you want to appear on the screen right away.
    \item \textbf{Example:}
          \begin{tcolorbox}
              \texttt{printf("What is your first name? ");} \\
              \texttt{fflush(stdout);} \\
              \texttt{scanf("\%s", firstName);}
          \end{tcolorbox}
    \item This ensures the question is visible before the program waits for the \texttt{scanf} input, even without a \texttt{\textbackslash n}. The user's answer will then appear on the same line as the question.
\end{itemize}

\subsection{Important Considerations}
\begin{itemize}
    \item \textbf{System Variability:} This buffering behavior is not consistent across all Linux systems. Some systems or C libraries might flush output more frequently, even without a newline.
    \item \textbf{Best Practice:} To write portable and predictable interactive programs, always ensure the output buffer is flushed. The two main ways are:
          \begin{enumerate}
              \item End your prompt strings with \texttt{\textbackslash n}.
              \item Call \texttt{fflush(stdout);} after the prompt.
          \end{enumerate}
\end{itemize}

\separator

\section{Use scanf and file redirection to simulate an input}

We can automate or simulate user input for interactive programs using pipes and file redirection. This is useful for testing or when running programs in scripts.

\subsection{Creating an Input File}
First, create a file containing the inputs expected by the program, separated by newlines.
\begin{itemize}
    \item \textbf{Example:} Create a file named \texttt{answers} with the following content:
          \begin{tcolorbox}
              sharrock \\
              remi \\
              18
          \end{tcolorbox}
    \item You can create this using \texttt{nano} or \texttt{cat > answers}.
\end{itemize}

\subsection{Method 1: Using Pipes}
You can pipe the output of a command (like \texttt{cat}) into your program.
\begin{itemize}
    \item \textbf{Command:} \texttt{cat answers | ./program}
    \item \textbf{Explanation:} The shell takes the output of \texttt{cat answers} and feeds it as standard input to \texttt{./program}. The \texttt{scanf} functions in the program read from this stream just as if it were typed on the keyboard.
\end{itemize}

\subsection{Method 2: Input Redirection}
You can redirect a file directly into the program's standard input using the less-than sign (\texttt{<}).
\begin{itemize}
    \item \textbf{Command:} \texttt{./program < answers}
    \item \textbf{Explanation:} This tells the shell to open the file \texttt{answers} and connect it to the input of \texttt{./program}.
    \item \textbf{Note:} This is the reverse of output redirection (\texttt{>}), which sends output to a file. Here, we send a file to the input.
\end{itemize}

\separator

\section{Donâ€™t use scanf, use fgets getline or readline}

Using \texttt{scanf} for string input can be dangerous and lead to unexpected behavior for both programmers and users.

\subsection{The Problem with scanf}
\texttt{scanf} splits input based on whitespace (spaces, tabs, newlines).
\begin{itemize}
    \item \textbf{Scenario:} A program asks for Family Name, First Name, and Age sequentially.
    \item \textbf{Input:} If the user types "Sharrock Remi 18" at the first prompt and hits Enter.
    \item \textbf{Result:}
          \begin{itemize}
              \item Family Name becomes "Sharrock".
              \item First Name automatically becomes "Remi" (consuming the next part of the buffer).
              \item Age automatically becomes "18".
          \end{itemize}
    \item The program skips waiting for the subsequent inputs because \texttt{scanf} consumed the space-separated values from the first line. This behavior makes \texttt{scanf} risky for robust user interaction.
\end{itemize}

\subsection{Better Alternatives}
To handle string input more safely, consider these functions:
\begin{itemize}
    \item \textbf{fgets:} Reads the entire line, including spaces. Note that it also captures the newline character (\texttt{\textbackslash n}) at the end, which you may need to remove.
    \item \textbf{getline:} A POSIX-standard function (available on most Unix-like systems) that reads an entire line.
    \item \textbf{GNU readline:} A powerful function specific to Linux/GNU systems.
\end{itemize}

For robust C programming, it is recommended to research these functions or take a dedicated C programming course.

\separator

\end{document}
