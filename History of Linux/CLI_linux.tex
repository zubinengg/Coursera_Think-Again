\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, mathtools}
\usepackage{tikz}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{float}
\usepackage{parskip}
\usepackage{tabularx}
\usepackage[utf8]{inputenc}
\usepackage{tgpagella}
\usepackage[T1]{fontenc}
\usepackage{array}
\usepackage{booktabs}
\usepackage{tcolorbox}
\usepackage{enumitem}

\newcommand{\separator}{\noindent\rule{\linewidth}{1pt}}

\title{History of Linux and the command line}
\author{Zubin}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\newpage

\separator
%-----------------------------------------------------------------


\section{Operating Systems: Definition and Services}

\subsection{What is an Operating System?}
An \textbf{operating system (OS)} is an intermediary between computer hardware (memory, processor, network cards, etc.) and the applications that users interact with.
\begin{itemize}
    \item Users interact with applications.
    \item Applications request services from the operating system.
    \item The operating system manages and exploits hardware resources to provide services to the applications.
\end{itemize}

\subsection{Examples of Operating Systems}
\begin{itemize}
    \item Microsoft Windows
    \item Apple macOS and iOS
    \item Google Android
    \item Unix and Unix-like systems such as Linux
\end{itemize}

\subsection{Unix and Linux}
\begin{itemize}
    \item Unix has been around longer than Linux.
    \item Linux is a \textbf{Unix-like, open-source operating system}. The Linux kernel, created by \textbf{Linus Torvalds} and expanded upon by thousands of programmers, is available to the world for free.
\end{itemize}

\subsection{Core Services Provided by an Operating System}

\subsubsection{File Management}
\begin{itemize}
    \item Managing the logical tree structure of files and their physical layout on storage devices (hard drives).
\end{itemize}

\subsubsection{Memory Management}
\begin{itemize}
    \item Allocation, deallocation, and sharing of memory among multiple running processes.
\end{itemize}

\subsubsection{Process Management}
\begin{itemize}
    \item Creation, execution, and termination of running applications (processes).
\end{itemize}

\subsubsection{Input/Output Management}
\begin{itemize}
    \item Managing hardware like network interfaces, sound cards, video cards, printers, and other peripherals.
\end{itemize}

\separator

\section{Genesis of Operating Systems}

\subsection{Early Computers (Mid-1940s)}
\begin{itemize}
    \item The first computers were built using \textbf{vacuum tubes} (evacuated glass containers that control electric current).
    \item These were huge machines that filled entire rooms but performed more slowly than a modern hand-held calculator.
\end{itemize}

\subsection{Programming and Operation}
\begin{itemize}
    \item Programming was done manually by rearranging hardware components.
    \item Input/output capabilities were very limited.
    \item A single individual often acted as the designer, builder, programmer, and operator.
\end{itemize}

\subsection{Invention of the Transistor}
\begin{itemize}
    \item The invention of the transistor led to smaller, more reliable computers.
    \item This innovation marked the beginning of operating systems through the appearance of \textbf{punch cards}.
\end{itemize}

\subsection{Punch Cards and Role Separation}
\begin{itemize}
    \item Punch cards are cards with holes in specific locations to encode computer programs and data.
    \item This led to a separation of roles: programmers prepared the punch cards, and operators physically loaded them into the computer and handled the output.
\end{itemize}

\subsection{Birth of Operating Systems}
\begin{itemize}
    \item Operating systems were invented to manage memory, processes (running programs), and input/output operations like reading punch cards.
    \item We can date the invention of operating systems to the \textbf{mid-1960s}.
\end{itemize}

\separator

\section{UNIX Genesis}

\subsection{Technological Context}
\begin{itemize}
    \item The era of modern computers emerged with the appearance of \textbf{integrated circuits} and magnetic disks.
    \item This period also saw the development of compatible computer families, such as the \textbf{IBM System/360} (1964), which made a clear distinction between architecture and implementation.
\end{itemize}

\subsection{Project MAC at MIT}
\begin{itemize}
    \item It all started with \textbf{Project MAC} (Mathematics and Computation), founded at MIT.
    \item It was funded by the US military's research agency (ARPA) and the National Science Foundation.
    \item The main goal was to develop a \textbf{timesharing system} that would allow a large community of users to access a single computer from multiple locations simultaneously.
\end{itemize}

\subsection{MULTICS}
\begin{itemize}
    \item Developed by MIT, Bell Labs, and General Electric
    \item Stands for \textbf{Multiplexed Information and Computing Service}
    \item It evolved beyond timesharing to incorporate features like file sharing, file management, and system security.
\end{itemize}

\subsection{Challenges of MULTICS}
\begin{itemize}
    \item The project proved much more difficult than expected.
    \item The system became operational in 1969 on the GE-645 computer, but its performance was far below the original targets.
    \item As a result, Bell Labs withdrew from the project in 1969.
\end{itemize}

\subsection{Birth of UNIX}
\begin{itemize}
    \item Following the withdrawal, Bell Labs engineers \textbf{Ken Thompson} and \textbf{Dennis Ritchie} decided to create a simpler, minimal system.
    \item Using a little-used DEC PDP-7 machine, they began developing a single-user operating system.
    \item As a pun on the complexity of MULTICS, they called their system \textbf{UNICS}.
\end{itemize}

\subsection{Evolution of UNIX}
\begin{itemize}
    \item In 1970, the system was enhanced to support multiple users, and its name morphed to \textbf{Unix}.
    \item At the time, the system was written in the \textbf{B programming language}, which was invented by Ken Thompson.
\end{itemize}

\subsection{The C Programming Language}
\begin{itemize}
    \item In 1971, Dennis Ritchie improved upon B and called it \textbf{New B}.
    \item By 1972, the changes were so significant that Ritchie renamed his new language the \textbf{C programming language}.
    \item Ken Thompson then rewrote the entire Unix operating system in C.
\end{itemize}

\subsection{Spread of UNIX}
\begin{itemize}
    \item The C source code for Unix was distributed to universities and research centers for educational purposes.
    \item From 1975 onward, a very active community emerged around Unix and C.
    \item Other notable developers included:
          \begin{itemize}
              \item Douglas McIlroy (McElroy)
              \item Joseph Ossanna
              \item Rudd Canaday
          \end{itemize}
\end{itemize}

\subsection{Key Milestones}
\begin{itemize}
    \item 1978: Brian Kernighan and Dennis Ritchie published the book \textit{The C Programming Language}.
    \item 1983: Thompson and Ritchie received the \textbf{Turing Award}, the highest distinction in computer science, for their invention.
\end{itemize}

\subsection{Legacy of UNIX}
\begin{itemize}
    \item The concepts introduced by Unix are ubiquitous today and form the foundation for many modern operating systems.
    \item Derivatives of Unix include:
          \begin{itemize}
              \item macOS
              \item iOS
              \item Android
              \item Linux, which is installed on the vast majority of today's servers and connected objects.
          \end{itemize}
\end{itemize}

\separator

\section{Linux genesis and history: GNU, Stallman, GPL, Linus Torvalds, Linux}

\subsection{The GNU Project}
\begin{itemize}
    \item In 1983, the same year Ritchie and Thompson received the Turing Award, \textbf{Richard Stallman} of MIT launched the \textbf{GNU Project}.
    \item GNU is a recursive acronym standing for \textbf{GNU is Not Unix}.
    \item The project aimed to develop a free, open, and collaborative software system compatible with Unix, contrasting with the proprietary nature of Unix owned by Bell Labs.
\end{itemize}

\subsection{Richard Stallman and the GPL}
\begin{itemize}
    \item Richard Stallman is a strong advocate for free and open-source software.
    \item In 1989, he conceived the \textbf{GNU General Public License (GPL)}, designed to preserve the freedom to use, study, modify, and distribute software.
    \item By 1990, the GNU Project had created many tools (text editors, GUI, libraries, and the \textbf{GNU C Compiler (GCC)}), but it lacked a free operating system kernel to run them on.
\end{itemize}

\subsection{Linus Torvalds and the Linux Kernel}
\begin{itemize}
    \item \textbf{Linus Torvalds}, a student at the University of Helsinki, was frustrated by proprietary OS licenses.
    \item On August 25, 1991, he announced a "free operating system" project (just a hobby) to the community.
    \item This became the \textbf{Linux kernel}, developed on an 80386 processor using the GNU C Compiler.
\end{itemize}

\subsection{Integration and Growth}
\begin{itemize}
    \item A community formed quickly, integrating GNU software with the Linux kernel.
    \item In 1992, the first \textbf{Linux distributions} were released (Linux kernel + GNU tools).
    \item By 1993, there were over 100 developers, and popular distributions like \textbf{Debian} emerged.
\end{itemize}

\subsection{Widespread Adoption}
\begin{itemize}
    \item \textbf{Late 1990s:} Major manufacturers (Dell, IBM, HP) announced Linux compatibility.
    \item \textbf{2000s:} Increasing deployment on web servers.
    \item \textbf{2010s:} Linux and Unix-based systems dominated:
          \begin{itemize}
              \item Internet servers (~70\%)
              \item Smartphones (~90\%, via Android and iOS)
              \item Supercomputers (~99\%)
          \end{itemize}
    \item Linux is also prevalent in game consoles, routers, and IoT devices.
\end{itemize}

\separator

\section{Command line interface, prompt, command options and files data, command cal as example}

\subsection{Definition and Interaction}
\begin{itemize}
    \item A \textbf{Command Line Interface (CLI)} is a human-machine interface where communication takes place in text mode.
    \item The user types a command to request an operation, and the computer displays the result or further questions in text.
    \item It is central to the interaction between users and computing equipment.
\end{itemize}

\subsection{The Command Prompt}
\begin{itemize}
    \item When ready to receive input, the system displays a \textbf{command prompt}.
    \item This prompt usually contains information like the user's name, computer name, current directory, or date.
    \item It ends with a character such as \texttt{\$}, \texttt{\#}, or \texttt{>}.
\end{itemize}

\subsection{Command Structure}
\begin{itemize}
    \item Unix and Linux systems include hundreds of simple applications usable from the CLI.
    \item The basic structure of a command is: \texttt{command options files\_or\_data}
    \item \textbf{Command:} The name of the application (often written in C).
    \item \textbf{Options:} Modify the command's execution (separated by spaces).
    \item \textbf{Files or Data:} The inputs for the program.
\end{itemize}

\subsection{Example: The \texttt{cal} Command}
\begin{itemize}
    \item Typing \texttt{cal} and pressing Enter runs the application that displays a calendar.
    \item Adding the \texttt{-j} option (e.g., \texttt{cal -j}) displays the calendar in Julian days (number of days elapsed since January 1st).
\end{itemize}

\separator

\section{First commands: echo 'hello world', date, cal, history, whoami, hostname, uptime, clear, command not found, man, command options}

\subsection{The Command Prompt}
The command prompt is the visual indicator that the system is ready to receive input. On WebLinux, it appears as a tilde, a space, a dollar sign, and a space (\texttt{\textasciitilde\ \$}), followed by a blinking cursor. When you type a command and press \textbf{Enter}, the shell interprets the command and displays the result.

\subsection{User and System Identification}
\begin{itemize}
    \item \textbf{whoami}: Displays the current username. On WebLinux, this is simply \texttt{user}.
    \item \textbf{logname}: Similar to \texttt{whoami}, it prints the name of the current user.
    \item \textbf{id}: Displays the user ID (UID) and group ID (GID). For the default user, these are typically 1000.
    \item \textbf{hostname}: Displays the name of the computer (e.g., \texttt{openrisk}).
    \item \textbf{uname}: Prints system information. By default, it prints the kernel name (\texttt{Linux}).
    \item \textbf{uname -a}: The \texttt{-a} option prints all system information, including the network node hostname, kernel release, and version.
\end{itemize}

\subsection{Basic Interaction and Output}
\begin{itemize}
    \item \textbf{echo}: Prints the arguments passed to it. For example, \texttt{echo hello} prints "hello".
    \item \textbf{echo \$0}: Displays the name of the shell interpreter (e.g., \texttt{sh}).
    \item \textbf{clear}: Clears the terminal screen.
    \item \textbf{history}: Displays a list of previously executed commands. You can use the \textbf{Up} and \textbf{Down} arrow keys to navigate through this history.
\end{itemize}

\subsection{Time and Date}
\begin{itemize}
    \item \textbf{uptime}: Displays how long the system has been running, along with the current time and load averages.
    \item \textbf{cal}: Displays a calendar. The \texttt{-j} option displays Julian dates (days numbered from 1 to 366).
    \item \textbf{date}: Displays the current date and time. It supports formatting options:
          \begin{itemize}
              \item \texttt{date +"\%T"}: Displays time only.
              \item \texttt{date +"\%A \%d \%B \%Y"}: Displays full weekday, day, month, and year.
          \end{itemize}
\end{itemize}

\subsection{Getting Help and Manuals}
\begin{itemize}
    \item \textbf{--help}: Many commands support this option to display usage summaries (e.g., \texttt{whoami --help}).
    \item \textbf{man}: The manual command. Typing \texttt{man <command>} usually opens the manual page for that command.
          \begin{itemize}
              \item On full Linux systems, this provides detailed documentation.
              \item On WebLinux, manual pages may be removed to save space, resulting in "no manual entry".
              \item Press \textbf{q} to exit the manual viewer and return to the prompt.
          \end{itemize}
\end{itemize}

\separator

\section{Interactive commands: top, htop, nano, vim, how to get back to the prompt}

\subsection{Interactive Programs}
Unlike basic commands that print output and return to the prompt immediately, interactive commands launch programs that take over the terminal interface. The command prompt (e.g., \texttt{\textasciitilde\ \$}) disappears, and the user must interact with the running program. To return to the command line, one must know how to exit these specific applications.

\subsection{System Monitoring: top and htop}
\begin{itemize}
    \item \textbf{top}: Provides a real-time view of process activity, CPU usage, and memory usage.
          \begin{itemize}
              \item \textbf{To Exit:} Press \textbf{q} or use the interrupt key combination \textbf{Ctrl+C} (often denoted as \texttt{\^{}C}).
          \end{itemize}
    \item \textbf{htop}: A more advanced, colorful version of \texttt{top} with graphical bars for system resources.
          \begin{itemize}
              \item \textbf{To Exit:} Press \textbf{F10}, \textbf{q}, or \textbf{Ctrl+C}.
          \end{itemize}
\end{itemize}

\subsection{Text Editors: nano and vim}
\begin{itemize}
    \item \textbf{nano}: A simple file editor. It displays a shortcut menu at the bottom where the caret symbol (\texttt{\^{}}) represents the Control key.
          \begin{itemize}
              \item \textbf{To Exit:} Press \textbf{Ctrl+X} (indicated as \texttt{\^{}X}).
              \item Note: \textbf{Ctrl+C} does not exit nano.
          \end{itemize}
    \item \textbf{vim}: A famous but complex editor. It operates in different modes (e.g., Insert mode for typing, Normal mode for commands).
          \begin{itemize}
              \item \textbf{To Exit:}
                    \begin{enumerate}
                        \item Press \textbf{Esc} to ensure you are in Normal mode.
                        \item Type \texttt{:q} (colon, q) and press \textbf{Enter}.
                        \item If changes were made and you want to force quit without saving, type \texttt{:q!} and press \textbf{Enter}.
                    \end{enumerate}
          \end{itemize}
\end{itemize}

\subsection{Summary of Exit Strategies}
If you are stuck in a program and want to return to the prompt:
\begin{enumerate}
    \item Try pressing \textbf{q} (quit).
    \item Try pressing \textbf{Ctrl+C} (interrupt).
    \item Look for on-screen help (e.g., \texttt{\^{}X} or \textbf{F10}).
    \item If in \texttt{vim}, use \textbf{Esc} followed by \texttt{:q!}.
\end{enumerate}

\separator

\section{Filesystem}

\subsection{Evolution of Storage}
One role of the operating system is to manage files. Historically, data was stored on punch cards, where huge physical volumes were required to store what now fits on a small flash drive (e.g., 4.3 billion characters). The advent of disk drives revolutionized programming by allowing millions of files to be stored and accessed instantly without physical handling.

\subsection{The File System Tree}
The file system is organized as a tree hierarchy:
\begin{itemize}
    \item \textbf{Root (\texttt{/})}: The starting point of the file system.
    \item \textbf{Directories}: Files are grouped into folders. A path is denoted using slashes, e.g., \texttt{/folder/subfolder/file}.
\end{itemize}

\subsection{Linux Directory Structure}
Based on the Filesystem Standard (FSSTND) initiated in 1993, most Linux distributions use the following directories:
\begin{itemize}
    \item \textbf{/bin}: Basic executable commands (binaries) for a minimal system.
    \item \textbf{/sbin}: System binaries for the \textbf{super user} (root).
    \item \textbf{/home}: Contains directories for standard users (e.g., \texttt{/home/user}).
    \item \textbf{/root}: The home directory specifically for the root user.
    \item \textbf{/etc}: Configuration files. Stands for \textbf{Editable Text Configuration}.
    \item \textbf{/lib}: Libraries required by binaries in \texttt{/bin} and \texttt{/sbin}.
    \item \textbf{/tmp}: Temporary files. Content is usually deleted upon restart.
    \item \textbf{/var}: Variable files such as logs (\texttt{/var/log}), databases, and emails.
    \item \textbf{/usr}: \textbf{Unix System Resources} (not "user"). Contains non-essential applications and libraries.
    \item \textbf{/dev}: Device files. Linux treats devices as files (e.g., \texttt{/dev/mem}, \texttt{/dev/audio}).
\end{itemize}

\separator

\section{pwd, cd, ls, absolute path, relative path (1)}

\subsection{Navigating the File System}
Navigation is a core skill in the Linux command line. The primary commands for this are \texttt{pwd}, \texttt{ls}, and \texttt{cd}.

\subsection{Print Working Directory (pwd)}
\begin{itemize}
    \item \textbf{pwd}: Stands for "print working directory".
    \item It displays the absolute path of the directory you are currently located in.
    \item When you first log in, you are typically in your home directory (e.g., \texttt{/home/user}).
    \item The tilde (\texttt{\textasciitilde}) in the command prompt represents this home directory.
\end{itemize}

\subsection{Listing Files (ls)}
\begin{itemize}
    \item \textbf{ls}: Lists the files and directories in the current working directory.
    \item \textbf{ls -a}: Lists all files, including \textbf{hidden files}.
          \begin{itemize}
              \item Hidden files and directories start with a dot (e.g., \texttt{.config}).
              \item This view reveals the special directories \texttt{.} (current) and \texttt{..} (parent).
          \end{itemize}
    \item \textbf{ls -al}: Combines options to show a detailed list of all files, including hidden ones.
          \begin{itemize}
              \item Lines starting with \texttt{d} are directories.
              \item Lines starting with \texttt{-} are regular files.
          \end{itemize}
\end{itemize}

\subsection{Changing Directories (cd)}
\begin{itemize}
    \item \textbf{cd}: Stands for "change directory".
    \item \textbf{cd /}: Moves to the root directory.
    \item \textbf{cd} (without arguments): Returns to the user's home directory.
    \item \textbf{cd ..}: Moves up one level to the parent directory.
\end{itemize}

\subsection{Absolute vs. Relative Paths}
\begin{itemize}
    \item \textbf{Absolute Path}:
          \begin{itemize}
              \item Always starts with the root directory slash (\texttt{/}).
              \item Describes the full path from the root to the destination (e.g., \texttt{/home/user}, \texttt{/sys/module}).
              \item It works from anywhere in the file system.
          \end{itemize}
    \item \textbf{Relative Path}:
          \begin{itemize}
              \item Does \textbf{not} start with a slash.
              \item Describes the path relative to the current working directory.
              \item \texttt{.} (dot): Refers to the current directory (e.g., \texttt{./sys} is the same as \texttt{sys}).
              \item \texttt{..} (dot dot): Refers to the parent directory.
              \item You can chain them (e.g., \texttt{../../} moves up two levels).
          \end{itemize}
\end{itemize}

\separator

\section{pwd, cd, ls, absolute path, relative path (2)}

This section covers how to determine a file's type, find the absolute path of a file or directory, and locate an installed program on the system.

\subsection{Getting File Type (file)}
The \texttt{file} command determines the type of a file.

\begin{itemize}
    \item \textbf{Source Code:} Running \texttt{file program.c} on a C source file will identify it as such.
          \begin{tcolorbox}
              \texttt{\$ file program.c} \\
              \texttt{program.c: C source, ASCII text}
          \end{tcolorbox}

    \item \textbf{Plain Text:} After creating a new file named \texttt{f} with some text using an editor like \texttt{nano}, the \texttt{file} command will identify it as ASCII text.
          \begin{tcolorbox}
              \texttt{\$ file f} \\
              \texttt{f: ASCII text}
          \end{tcolorbox}

    \item \textbf{Directory:} The command can also identify directories.
          \begin{tcolorbox}
              \texttt{\$ file /bin} \\
              \texttt{/bin: directory}
          \end{tcolorbox}

    \item \textbf{Symbolic Link:} Some files are symbolic links, which are pointers to other files. The \texttt{file} command reveals this relationship.
          \begin{tcolorbox}
              \texttt{\$ file /bin/cat} \\
              \texttt{/bin/cat: symbolic link to /bin/busybox}
          \end{tcolorbox}

    \item \textbf{Executable Binary:} Following the symbolic link, we can inspect the actual program file. Executable files are often in ELF (Executable and Linkable Format).
          \begin{tcolorbox}
              \texttt{\$ file /bin/busybox} \\
              \texttt{/bin/busybox: ELF 32-bit LSB executable, OpenRISC...}
          \end{tcolorbox}
          This output indicates it is a 32-bit executable program for the OpenRISC processor architecture.

    \item \textbf{Other System Files:} The file system contains many types of files. For example, in \texttt{/sys/kernel}:
          \begin{itemize}
              \item \texttt{file notes} might return something complex like \texttt{X11 SNF font data, MSB first}.
              \item \texttt{file fscaps} might return something simple like \texttt{ASCII text}.
          \end{itemize}
\end{itemize}

\subsection{Finding the Real Path (realpath)}
The \texttt{realpath} command resolves all symbolic links and references to \texttt{.} and \texttt{..} to print the canonical absolute path of a file or directory.
\begin{itemize}
    \item For a simple file in the home directory, it returns the full path.
          \begin{tcolorbox}
              \texttt{\$ realpath f} \\
              \texttt{/home/user/f}
          \end{tcolorbox}
    \item For a symbolic link, it returns the path of the file it points to.
          \begin{tcolorbox}
              \texttt{\$ realpath /bin/cat} \\
              \texttt{/bin/busybox}
          \end{tcolorbox}
\end{itemize}

\subsection{Locating Executables (which)}
The \texttt{which} command shows the full path of an executable program by searching the directories listed in the user's \texttt{PATH} environment variable. This is useful for finding where a command is installed.
\begin{itemize}
    \item \texttt{which realpath} $\rightarrow$ \texttt{/usr/bin/realpath}
    \item \texttt{which cat} $\rightarrow$ \texttt{/bin/cat}
    \item \texttt{which ls} $\rightarrow$ \texttt{/bin/ls}
    \item \texttt{which file} $\rightarrow$ \texttt{/usr/bin/file}
    \item You can even find the location of the \texttt{which} command itself: \\
          \texttt{which which} $\rightarrow$ \texttt{/usr/bin/which}
\end{itemize}

\separator

\section{Touch, rm, names with spaces}

\subsection{Creating Files (touch)}
We have seen how to create files using a text editor like \texttt{nano}. A simpler way to create an empty file without opening an editor is using the \texttt{touch} command.
\begin{itemize}
    \item \textbf{Command:} \texttt{touch filename}
    \item \textbf{Example:} \texttt{touch file} creates an empty file named "file".
\end{itemize}

\subsection{Deleting Files (rm)}
To delete (remove) files, use the \texttt{rm} command.
\begin{itemize}
    \item \textbf{Command:} \texttt{rm filename}
    \item \textbf{Example:} \texttt{rm f} deletes the file named "f".
    \item \textbf{Warning:} Deleted files are removed permanently and do not go to a trash bin.
\end{itemize}

\subsection{Filenames with Spaces}
Spaces in filenames can cause issues because the shell interprets spaces as separators between arguments.

\subsubsection{The Problem}
If you try to create a file with spaces like \texttt{touch my space file}, the shell interprets this as a request to create three separate files: "my", "space", and "file".

\subsubsection{The Solutions}
To handle spaces correctly, you have two main options:
\begin{enumerate}
    \item \textbf{Backslash Escape:} Use a backslash (\texttt{\textbackslash}) before the space to tell the shell it is part of the name.
          \begin{tcolorbox}
              \texttt{\$ touch my\textbackslash\ file}
          \end{tcolorbox}
    \item \textbf{Quotes:} Enclose the entire filename in single (\texttt{' '}) or double (\texttt{" "}) quotes.
          \begin{tcolorbox}
              \texttt{\$ touch 'my file'}
          \end{tcolorbox}
\end{enumerate}
To remove these files, you must use the same methods (e.g., \texttt{rm 'my file'} or \texttt{rm my\textbackslash\ file}).

\subsubsection{Best Practice}
It is generally recommended to avoid spaces in filenames to prevent these issues. Use underscores (\texttt{\_}) or hyphens (\texttt{-}) instead (e.g., \texttt{my\_file}).

\subsection{Getting Unstuck (Quotes and Brackets)}
If you open a quote (single or double), parenthesis, or bracket but forget to close it before pressing Enter, the shell will wait for you to finish the input. The prompt changes (often to \texttt{>}), and standard commands like \texttt{ls} or \texttt{Ctrl+C} might not work immediately.

\textbf{How to exit:}
\begin{enumerate}
    \item \textbf{Close the pair:} Type the missing closing character (quote, bracket, etc.) and press Enter. The command will likely fail (e.g., "command not found"), but you will return to the main prompt.
    \item \textbf{Control+D:} Pressing \texttt{Ctrl+D} sends an "End of File" (EOF) signal. You might need to press it twice or press Enter first to ensure you are on a new line.
\end{enumerate}

\separator

\section{cat less}
This section covers how to read and create files using \texttt{cat} and output redirection, and how to view long outputs using the \texttt{more} and \texttt{less} commands.

\subsection{Reading and Writing Files (cat, >)}
\begin{itemize}
    \item \textbf{Reading Files:} The \texttt{cat} command (short for "concatenate") is used to print the contents of a file to the terminal.
          \begin{tcolorbox}
              \texttt{\$ cat file.txt} \\
              \texttt{here is a text file} \\
              \texttt{with a second line}
          \end{tcolorbox}

    \item \textbf{Output Redirection (>):} The greater-than sign (\texttt{>}) redirects the output of a command into a file instead of printing it to the screen. This will overwrite the file if it already exists.
          \begin{tcolorbox}
              \texttt{\$ echo "hello world" > file2.txt}
          \end{tcolorbox}
          This command creates \texttt{file2.txt} containing the text "hello world". This can also be used to copy file contents:
          \begin{tcolorbox}
              \texttt{\$ cat file2.txt > file3.txt}
          \end{tcolorbox}

    \item \textbf{Creating Files with cat:} You can use \texttt{cat} to create a file directly from your keyboard input.
          \begin{tcolorbox}
              \texttt{\$ cat > anotherfile.txt} \\
              \texttt{this is another file} \\
              \texttt{with a new second line} \\
              \texttt{Ctrl+D}
          \end{tcolorbox}
          After typing the command, the terminal waits for your input. Press \textbf{Ctrl+D} on a new line to signal the end of the file and return to the prompt.
\end{itemize}

\subsection{Viewing Long Output (Pipes, more, less)}
When the output of a command is too long to fit on the screen (e.g., \texttt{cat /etc/services}), it scrolls by too quickly. To manage this, we can "pipe" the output to a pager program. The pipe operator (\texttt{|}) sends the output of one command to the input of another.

\subsubsection{The \texttt{more} Command}
\texttt{more} is a basic pager that displays text one screen at a time.
\begin{itemize}
    \item \textbf{Usage:} \texttt{cat /etc/services | more} or \texttt{more filename.txt}
    \item \textbf{Navigation:}
          \begin{itemize}
              \item \textbf{Spacebar}: Go to the next page.
              \item \textbf{q} or \textbf{Ctrl+C}: Quit.
          \end{itemize}
    \item It is a simple tool, and \texttt{less} is often preferred.
\end{itemize}

\subsubsection{The \texttt{less} Command}
\texttt{less} is a more advanced and powerful pager ("less is more").
\begin{itemize}
    \item \textbf{Usage:} \texttt{ls /usr/bin | less} or \texttt{less filename.txt}
    \item \textbf{Navigation:}
          \begin{itemize}
              \item \textbf{Arrows (Up/Down)}: Scroll line by line.
              \item \textbf{j} / \textbf{k}: Move down / up one line.
              \item \textbf{Spacebar}: Scroll forward one page.
              \item \textbf{g} (lowercase): Go to the beginning of the text.
              \item \textbf{G} (uppercase): Go to the end of the text.
              \item \textbf{q}: Quit.
          \end{itemize}
\end{itemize}

\subsubsection{Searching in \texttt{less}}
\texttt{less} allows you to search through the text.
\begin{itemize}
    \item \textbf{/pattern}: Search forward for the given pattern.
    \item \textbf{?pattern}: Search backward for the given pattern.
    \item \textbf{n}: Jump to the next match.
    \item \textbf{N} (uppercase): Jump to the previous match.
\end{itemize}
\begin{tcolorbox}
    \texttt{\$ ls /usr/bin | less} \\
    (Inside less, type \texttt{/joe} and press Enter to search for "joe")
\end{tcolorbox}

\subsubsection{Options for \texttt{less}}
\texttt{less} can be customized with command-line options.
\begin{itemize}
    \item \textbf{-N}: Display line numbers.
    \item \textbf{-M}: Display a more detailed status line, including the percentage through the file.
\end{itemize}
\begin{tcolorbox}
    \texttt{\$ ls /usr/bin | less -NM}
\end{tcolorbox}
This will show the list of files with line numbers and a status bar at the bottom.

\separator

\section{mkdir, rm -r}
This section explains how to create and delete directories (folders).

\subsection{Creating Directories (mkdir)}
The \texttt{mkdir} command is used to "make directories".
\begin{itemize}
    \item \textbf{Single Directory:} To create one directory.
          \begin{tcolorbox}
              \texttt{\$ mkdir folder}
          \end{tcolorbox}
    \item \textbf{Multiple Directories:} To create several directories at the same level.
          \begin{tcolorbox}
              \texttt{\$ mkdir d1 d2 d3}
          \end{tcolorbox}
    \item \textbf{Nested Directories (-p):} To create a directory and any necessary parent directories that do not already exist, use the \texttt{-p} (parents) option.
          \begin{tcolorbox}
              \texttt{\$ mkdir -p D1/D2/D3}
          \end{tcolorbox}
          This command creates directory \texttt{D3} inside \texttt{D2}, which is inside \texttt{D1}.
\end{itemize}

\subsection{Deleting Directories (rm -r)}
The standard \texttt{rm} command does not delete directories. To do so, you must use the recursive option.

\begin{itemize}
    \item \textbf{Recursive Deletion (-r):} The \texttt{-r} (or \texttt{--recursive}) option tells \texttt{rm} to delete a directory and all of its contents, including subdirectories.
          \begin{tcolorbox}
              \texttt{\$ rm -r folder}
          \end{tcolorbox}
          \textbf{Warning:} This command is extremely powerful and deletes files and directories permanently without confirmation. Use it with great care.

    \item \textbf{Interactive Deletion (-i):} To add a layer of safety, combine the \texttt{-r} option with \texttt{-i} (interactive). This will prompt you to confirm every deletion.
          \begin{tcolorbox}
              \texttt{\$ rm -ri folder} \\
              \texttt{rm: descend into directory 'folder'? y} \\
              \texttt{rm: remove regular empty file 'folder/f1'? y} \\
              \texttt{rm: remove directory 'folder'? y}
          \end{tcolorbox}

    \item \textbf{Automating Confirmation (yes):} The \texttt{yes} command repeatedly outputs 'y'. You can pipe its output to an interactive command to automatically answer "yes" to all prompts.
          \begin{tcolorbox}
              \texttt{\$ yes | rm -ri folder}
          \end{tcolorbox}
          This command will automatically confirm and delete the \texttt{folder} directory and all its contents.
\end{itemize}

\end{document}
